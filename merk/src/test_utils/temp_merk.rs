use std::{
    ops::{Deref, DerefMut},
    path::Path,
    rc::Rc,
};

use tempdir::TempDir;

use crate::Merk;

/// Wraps a Merk instance and deletes it from disk it once it goes out of scope.
pub struct TempMerk {
    pub inner: Merk,
    pub path: TempDir,
}

impl TempMerk {
    /// Opens a `TempMerk` at an autogenerated, temporary file path.
    pub fn new() -> TempMerk {
        let path = TempDir::new("db").expect("cannot create tempdir");
        let db = default_rocksdb(path.path());
        TempMerk {
            inner: Merk::open(db, Vec::new()).expect("cannot open Merk"),
            path,
        }
    }
}

pub fn default_rocksdb(path: &Path) -> Rc<rocksdb::DB> {
    Rc::new(
        rocksdb::DB::open_cf_descriptors(&Merk::default_db_opts(), &path, crate::column_families())
            .expect("cannot create rocksdb"),
    )
}

impl Deref for TempMerk {
    type Target = Merk;

    fn deref(&self) -> &Merk {
        &self.inner
    }
}

impl DerefMut for TempMerk {
    fn deref_mut(&mut self) -> &mut Merk {
        &mut self.inner
    }
}
